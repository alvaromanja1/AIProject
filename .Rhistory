state <- c(1,1,1)
action <- c(2,1)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}
}
state <- c(1,1,1)
action <- c(1,2)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}
}
state <- c(1,1,1)
action <- c(1,3)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}
}
state <- c(1,1,1)
action <- c(3,3)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error")
}
}
state <- c(1,1,1)
action <- c(3,1)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error")
}
}
state <- c(1,1,1)
action <- c(3,1)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
}
}
state <- c(1,1,1)
action <- c(3,1)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
state <- c(1,1,1)
action <- c(1,1)
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
state <- c(1,1,1)
action <- c(1,1)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
}
else{
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
}
state <- c(1,1,1)
action <- c(1,1)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
return(FALSE)
}
else{
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover por que ya hay un disco menor en el palo destino")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
}
state <- c(1,1,1)
action <- c(1,1)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
return(FALSE)
}
state <- c(1,1,1)
action <- c(1,2)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
return(FALSE)
}
state <- c(1,1,1)
action <- c(1,2)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
return(FALSE)
}
else{
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
}
state <- c(1,1,1)
action <- c(1,3)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
return(FALSE)
}
else{
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
}
state <- c(1,1,1)
action <- c(2,3)
if(action[1]==action[2]){
print("El origen de la acción no puede ser igual al destino ")
return(FALSE)
}
else{
for(i in 1: length(state)){
if(state[i]==action[1]){
print("Aplicaremos la acción al número correspondiente al contenido de la posición i del vector state")
for(j in 1: i){
if(state[j]==action[2] | action[2]>length(state)){
print("No se puede mover")
return(FALSE)
}
else{
print("El disco se puede mover")
return(TRUE)
}
}
}else{
print("Error, el origen de la acción es incorrecto, la acción no se puede realizar")
return(FALSE)
}
}
}
firstnode = frontier[[1]]
frontier[[1]] = NULL
frontier = list(node)
node = list()
node$state = initialstate
node$actions = c(0,0)
startTime<-Sys.time() #Hora actual de inicio
print(startTime)
startTime<-Sys.time() #Hora actual de inicio
print(startTime)
print(a)
startTime<-Sys.time() #Hora actual de inicio
print(startTime)
print("a")
endTime<-Sys.time()
print(endTime)
startTime<-Sys.time() #Hora actual de inicio
print(startTime)
print("a")
endTime<-Sys.time()
print(endTime)
timeTaken <-endTime - startTime #Tiempo que tarda el programa en ejecutarse; final - inicio
print(timeTaken)
View(h)
View(m)
View(mat)
View(matrix)
View(toString)
ndisks = 4
nrods = 3
matrix = matrix(0:0,nrow=ndisks, ncol=nrods) #llenamos la matriz de ceros
for(i in 1: ndisks){ #recorremos las filas de la matriz desde 1 hasta num discos
for(j in 1: nrods){ #recorremos las columnas de la matriz desde 1 hasta num palos
if(state[j] == i){
matrix[j,i] <- j #insertamos en la posicion[j, i] el valor del disco
}
}
}
m=apply(matrix, 2, sort) #aplica una funci?n a los m?rgenes de una matriz; ordena
state <- c(1,1,1,1)
ndisks = 4
nrods = 3
matrix = matrix(0:0,nrow=ndisks, ncol=nrods) #llenamos la matriz de ceros
for(i in 1: ndisks){ #recorremos las filas de la matriz desde 1 hasta num discos
for(j in 1: nrods){ #recorremos las columnas de la matriz desde 1 hasta num palos
if(state[j] == i){
matrix[j,i] <- j #insertamos en la posicion[j, i] el valor del disco
}
}
}
m=apply(matrix, 2, sort) #aplica una funci?n a los m?rgenes de una matriz; ordena
print(m) #imprimimos la matriz
library("ggplot2", lib.loc="~/R/win-library/3.5")
install.packages("ggplot2")
install.packages("tidyverse")
# Paso 3, definir una matriz con el número de etiquetas de cada entrada
#definimos una matriz de
num.fvalinput = matrix(c(3,3), nrow=1)
View(num.fvalinput)
# Con los siguientes dos comandos limpiamos el entorno de trabajo y la consola
rm(list = ls())
cat("\014")
# Otro punto es establecer el working directory, con este comando hacemos que
# éste sea igual a aquél en el que se encuentra el script
# Si es tu 1ª vez con R, tendrás que instalar el paquete rstudioapim
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#Librerías
library(frbs)
library(ggplot2)
library(scales)
library(SmarterPoland)
library(htmltools)
library(rlist)
library(shiny)
library(darksky)
library(weathermetrics)
file = 'Apikey.txt'
APIKEY = readChar(file, file.info(file)$size)
#leer los csv's
weather = read.csv("csv/Weather Madrid.csv",check.names=FALSE)
presionBaja = c(2,980, 1005, 1012, NA) #Aquí se ha decidido empezar por 0, ya que es el mínimo valor, luego que a partir de 1.25 empieze a dejar de ser una aplicación con rating "bajo", para que así, poco antes de la mitad deje de ser una aplicación con rating "bajo"
presionMedia = c(4, 1008, 1014, 1018 , 1021)#Aquí empezamos por 1.75 para que haya más margen hasta el 2.5 (que sería la mitad exacta), luego a partir de 3.25 consideramos que empieza a dejar de ser una app "normal", hasta llegar a 4
presionAny = c(4,980,980,1047,1047)
presionAlta = c(3,1018, 1030, 1047, NA)#Por último, consideramos que una app empieza a ser el rating "alto" a partir de 3.5, hasta 4.5, donde de ahí en adelante (hasta 5), se puede considerar una App con rating "alto"
tempMedia = c(4,10, 15, 18, 22) #Aquí empezamos a considerar como "algunos" las apps con valor de 23, hasta 35, donde empeiezan ya a ser miembros de "pleno derecho" al conjunto (se hace así ya que hay grandes saltos entre dispositivos conectados). Por último, se considera que a partir de 37, empiezan a estar menos en el medio, hasta llegar a 40
tempBaja = c(2, -6 , 5 , 12 , NA) #Aquí empezamos por 9, ya que es el mínimo, empezamos a reducir su pertenencia a partir de 16, y consideramos que dejan de ser "pocos" los dispositivos soportados a partur de 25
tempAlta = c(3,20, 26, 39, NA)
tempAny = c(4,-6,-6,39,39)
humedadBaja = c(2, 16 , 30 , 40 , NA)
humedadMedia = c(4,35, 49, 65, 72)
humedadAny = c(4,16,16,100,100)
humedadAlta = c(3,70, 81, 99, NA)
varinp.mf = cbind(tempBaja,tempMedia,tempAlta,tempAny,humedadBaja,humedadMedia,humedadAlta,humedadAny,presionBaja,presionMedia,presionAlta,presionAny)
num.fvalinput = matrix(c(4,4,4), nrow=1)
varinput1 = c("Baja", "Media", "Alta","Any")
varinput2 = c("Reducida","Intermedia","Grande","Any")
varinput3 = c("Poca", "Algo", "Mucha","Any")
names.varinput = c(varinput1, varinput2,varinput3)
range.data = matrix(c( -6, 39, 16, 100, 980, 1047, 0, 100), nrow = 2)
#Temp minima historia bilbao: -6, Max: 41
type.defuz = "COG"
type.tnorm = "MIN"
type.implication.func = "MIN"
type.snorm = "MAX"
name = "Probabilidad de lluvia" #Le damos nombre
newdata = weather[,c("Mean.TemperatureC", "Mean.Humidity","Mean.Sea.Level.PressurehPa")]
type.model = "MAMDANI" #Indicamos el tipo de modelo que vamos a usar
probBaja = c(2,0, 20, 40, NA)#Consideramos que una app es "mala" si tiene entre 0 y 20 puntos, a partir de la cual pensamos que deja de ser tam mala, hasta llegar a la valoración de 40
probMedia = c(4,30, 45, 55, 70) #Consideramos que una app empieza a ser "regular" a partir de los 30 puntos, hasta llegar a los 45 puntos; y empieza a dejar de ser "regular" a partir de los 55, hasta llegar a los 70 puntos
colnames.var = c("Temperatura", "Humedad","Presion", "Resultado")
probAlta = c(3,65, 85, 100, NA)
varoutput1 = c("Baja", "Media", "Alta") #Indicamos sus nombres
varout.mf = cbind(probBaja,probMedia,probAlta)
rule = matrix( c("Baja", "and", "Grande" , "and" , "Any","->", "Alta",
"Baja", "and","Intermedia" , "and" , "Poca","->", "Alta",
"Baja", "and","Intermedia" , "and" , "Algo","->", "Media",
"Baja", "and","Intermedia", "and"  , "Mucha","->", "Media",
"Baja", "and","Reducida" , "and" , "Any","->", "Media",
"Media", "and","Grande" , "and" , "Poca","->", "Alta",
"Media", "and","Grande" , "and" , "Algo","->", "Alta",
"Media", "and","Grande" , "and" , "Mucha","->", "Media",
"Media", "and","Intermedia", "and"  , "Poca","->", "Alta",
"Media", "and","Intermedia" , "and" , "Algo","->", "Media",
"Media", "and","Intermedia" , "and" , "Mucha","->", "Media",
"Media", "and","Reducida"  , "and", "Any","->", "Media",
"Alta", "and","Grande", "and"  , "Poca","->", "Media",
"Alta", "and","Grande", "and"  , "Algo","->", "Media",
"Alta", "and","Grande" , "and" , "Mucha","->", "Baja",
"Alta", "and","Intermedia" , "and" , "Poca","->", "Media",
"Alta", "and","Intermedia" , "and" , "Algo","->", "Baja",
"Alta", "and","Intermedia" , "and" , "Mucha","->", "Baja",
"Alta", "and","Reducida" , "and" , "Any","->", "Baja"
), nrow = 19, byrow = TRUE)
num.fvaloutput = matrix(c(3), nrow = 1)
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, varoutput1, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
res = predict(sistema, newdata)$predicted.val
newdata$probabilidad = res
newdata$id = seq.int(nrow(weather))
result = merge(weather, newdata, by.x = 'Id', by.y = 'id')
result = result[,c(1,2,3,4,5,6,7,8,12)]
# Obtenemos el portentaje de acierto
accuracy = function(result){
right = 0
rain = 0
event = ""
prob = 0
for(i in 1:nrow(result)){
rain = result[i,7]
event = result[i,8]
prob = result[i,9]
if(rain > 0 || event != ""){
if(prob >= 50){
right = right + 1
}
}else{
if(prob < 50){
right = right + 1
}
}
}
precision = (right / nrow(result) ) *100
return(precision)
}
test = accuracy(result)
test
names(unlist(APIKEY))
location = 'Madrid'
#Coordenadas para saber el tiempo en bilbao
long = -3.6827461
lat = 40.4893538
#establecemos las fechas de mañana y pasado para realizar las predicciones
tomorrowDate = paste(Sys.Date()+1, "12:00:00-0400", sep="T")
theDayAfterTomorrowDate = paste(Sys.Date()+2, "12:00:00-0400", sep="T")
forecast = getWeatherForecast(APIKEY, city=location)
realTemp = forecast[[1]]
# Obtenemos del dataset la hora actual para dibujar una luna en caso de que sea de noche
currentTime = realTemp$time;
View(newdata)
View(realTemp)
# Hacemos un substring para guardar en currentTime la hora actual
currentTime = substr(currentTime, 12, 19)
realTemp$icon = NULL
realTemp$apparentTemperature = NULL
realTemp$dewPoint = NULL
realTemp$temperature = NULL
realTemp$windSpeed = NULL
realTemp$windBearing = NULL
realTemp$cloudCover = NULL
realTemp$uvIndex = NULL
realTemp$visibility = NULL
realTemp$ozone = NULL
realTemp$apparentTemperatureCelsius = NULL
realTemp2 = realTemp[,c("temperatureCelsius","humidity","pressure")]
View(realTemp2)
realTemp2$humidity = realTemp$humidity * 100
res = predict(sistema, realTemp2)$predicted.val
# Redondeamos el resultado de la prediccion, temperatura y humedad
res = round(res,digits=0)
realTemp2$humidity = round(realTemp2$humidity,digits=0)
realTemp2$temperatureCelsius = round(realTemp2$temperatureCelsius,digits=0)
#A partir de aquí sacamos la predicción de los siguientes días. Con ello lo volcaremos a la interfaz
# Dia 2
dailyForecast = get_forecast_for(lat,long, tomorrowDate)
day2 = dailyForecast[[2]]
tomorrowTemp = day2[,c("temperatureMin", "temperatureMax", "humidity","pressure")]
View(tomorrowTemp)
tomorrowTemp$humidity = day2$humidity * 100
tomorrowTemp$temperatureMin = fahrenheit.to.celsius(day2$temperatureMin)
tomorrowTemp$temperatureMax = fahrenheit.to.celsius(day2$temperatureMax)
tomorrowTemp$temperature = (tomorrowTemp$temperatureMin + tomorrowTemp$temperatureMax) / 2
tomorrowTemp = tomorrowTemp[,c("temperature", "humidity","pressure")]
View(tomorrowTemp)
Tomorrowres = predict(sistema, tomorrowTemp)$predicted.val
Tomorrowres = round(Tomorrowres,digits=0)
tomorrowTemp$humidity = round(tomorrowTemp$humidity,digits=0)
tomorrowTemp$temperature = round(tomorrowTemp$temperature,digits=0)
View(tomorrowTemp)
runApp()
runApp()
runApp()
